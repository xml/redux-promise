redux-promise
=============

<!-- [![build status](https://img.shields.io/travis/acdlite/redux-promise/master.svg?style=flat-square)](https://travis-ci.org/acdlite/redux-promise)
[![npm version](https://img.shields.io/npm/v/redux-promise.svg?style=flat-square)](https://www.npmjs.com/package/redux-promise) -->

[FSA](https://github.com/acdlite/flux-standard-action)-compliant promise [middleware](https://github.com/gaearon/redux/blob/master/docs/middleware.md) for Redux. Forked from the estimable [acdlite](https://github.com/acdlite/) in order to add new features and evolve the pattern...

```js
npm install --save git+https://git@github.com/xml/redux-promise-keeper.git
```
(Should be on NPM soon, once stable in new incarnation.)

Regarding versioning, I've bumped it to 0.6.0 at the fork. 

## How is it different from the original redux-promise? 

It's all about the 'keeper'. redux-promise treats promises a bit like they're simply a callback alternative, hiding them from the rest of the redux lifecyle (from reducers or other middleware). Instead, we pass them along so they can be cached on the store and their full power used as an expression of the state of the operation.

This requires being explicit when you're handling actions generated by promise-producing action-creators: you'll need to check for `status` before processing it. But it gets us something very powerful: we're now able to use the full power of promises by using them as chainable representations of the state of the operation, from other contexts. For example: if you launch a network request on one route, or from one component, and you want to check the status of the request (to await completion or launch a new one) from another route or component, you'll now have the promise available at the store so you can do that.

This helps with a few important things:
* decouples implementation of the network request from consumption of the data
* improves user-experience and reduces network traffic by avoiding repeated requests for the same data
* lets you make full use of the promise API for monitoring operations

We're also solving for one more detail: in the handler method we use in reducers, we're not only caching the promise so you can chain it, we're also providing an indication of the status of the operation which you can inspect synchronously. (Somehow, the ability to do this was left entirely out of the ES6 promise spec, so it needs to be added. Note that if you use a library like Bluebird in lieu of native promises, you not solve this particular problem, but you also gain better performance, better error-handling, et al. Bluebird should be fully compatible with this library.)

## Usage

```js
import promiseMiddleware from 'redux-promise-keeper';
```

The default export is a middleware function. If it receives a promise, it will dispatch the resolved value of the promise. It will not dispatch anything if the promise rejects.

If it receives an Flux Standard Action whose `payload` is a promise, it will 

Then, on a change in the state of the promise, it will either: 

- dispatch a copy of the action with the resolved value of the promise, and set `status` to `success`.
- dispatch a copy of the action with the rejected value of the promise, and set `error` property to `true`.

The middleware returns a promise to the caller so that it can wait for the operation to finish before continuing. This is especially useful for server-side rendering. If you find that a promise is not being returned, ensure that all middleware before it in the chain is also returning its `next()` call to the caller.

## Using in combination with redux-actions

Because it supports FSA actions, you can use redux-promise in combination with [redux-actions](https://github.com/acdlite/redux-actions).

### Example: Async action creators using Async/Await Pattern

```js
createAction('FETCH_THING', async id => {
  const result = await somePromise;
  return result.someValue;
});
```


### Example: Integrating with a web API module

Say you have an API module that sends requests to a server. This is a common pattern in Flux apps. Assuming your API module produces promises, it's really easy to make some action creators that wrap around it:

```js
import { WebAPI } from '../utils/WebAPI';

export const getThing = createAction('GET_THING', WebAPI.getThing);
export const createThing = createAction('POST_THING', WebAPI.createThing);
export const updateThing = createAction('UPDATE_THING', WebAPI.updateThing);
export const deleteThing = createAction('DELETE_THING', WebAPI.deleteThing);
```

(This could be simplified into a single expression using something like lodash's `mapValues()`.)

## Requirements
redux-promise and redux-promise-keeper both assume your system supports ES6.

